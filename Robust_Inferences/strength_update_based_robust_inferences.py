# -*- coding: utf-8 -*-
"""Strength_Update_Based_Robust_Inferences.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14dUSs0ls7IWZ7VdVU49m07pQ63VBIq5R
"""

import numpy as np
from itertools import product

from qbaf import QBAFramework, QBAFARelations
from Robust_Inferences. general_robust_inferences import check_general_robust_inferences

"""
 This function returns a list of dictornaries:
 for each dictonary, the keys are elements of 'argstar' and
 the corresponding values are a number between (- 'epsilon', + 'epsilon')
"""

def generate_strength_update_values ( qbaf, argstar, epsilon ):

  """
  'values' is a list of all the values in (- 'epsilon', + 'epsilon'),
   with 0.01 increment and 'values_for_argstar' will be the list we return
  """

  values = [ ]
  values_for_argstar = [ ]


  for x in np.arange ( -float( epsilon ), float( epsilon ), 0.01 ):
      values. append ( str ( round ( x, 3 ) ) )

  """
  'values_buffer' is the permutation of all the values in 'values',
   repeated to match the length of 'argstar'
   In other words, these are the keys.
  """

  n = len ( argstar )
  values_buffer = product ( values, repeat = n )

  """
  'dictionary_buffer' is a local dictionary containing suceptible set and possible update pairs.
   It gets appended to 'values_for_argstar' at each iteration of the loop.
  """

  for x in values_buffer :

    dictionary_buffer = {}
    l = 0

    for y in argstar :
      dictionary_buffer. update ( { y : x[l] } )
      l += 1

    values_for_argstar.append ( dictionary_buffer )


  return values_for_argstar

from itertools import product

"""
 This function takes a qbaf, the susceptible set of arguments
 along with stength update "tolerance".
 It returns an updated QBAF witth initial strengths
 modified by at-most +-epsilon, for the susceptible set.
"""

def generate_strength_update( qbaf, args, epsilon ) :

  args_G = [ ]
  initial_strength_G = [ ]
  atts_G = [ ]
  supps_G = [ ]

  """
   The loop generates the argument set,
   checks whether the an argument is in 'agrs':
   if yes then it changes it based on 'epsilon', otherwise it remains the same
   as the original qbaf.
  """

  for x in qbaf. arguments :

    args_G. append ( x )

    if x in args :
      initial_strength_G. append ( qbaf. initial_strengths[ x ] + float ( epsilon[ x ] ) )

    else:
      initial_strength_G. append ( qbaf. initial_strengths[ x ] )

  for x in qbaf. attack_relations :
    atts_G. append ( x )

  for x in qbaf. support_relations :
    supps_G. append ( x )


  return QBAFramework ( args_G, initial_strength_G, atts_G, supps_G )

"""
 This function uses 'generate_strength_update' and 'generate_strength_values'
 to generate the  (initial) strength update based collection for a given 'qbaf'
"""

def generate_strength_update_collection ( qbaf, argstar, epsilon ) :

  values = generate_strength_update_values ( qbaf, argstar, epsilon )
  qbaf_collection = [ ]

  for x in values :
    qbaf_collection.append ( generate_strength_update ( qbaf, argstar, x ) )

  return qbaf_collection

"""
 Creates a collection 'G' of QBAF updates using 'qbaf', 'argstar' and 'epsilon'
 and checks for robustness w.r.t.  members of 'G' and arguments 'inference_1' and 'inference_2'
"""

def check_update_based_robust_inferences ( qbaf, argstar, epsilon, inference_1, inference_2 ) :

  G = generate_strength_update_collection ( qbaf, argstar, epsilon )

  for x in G:

    if ( qbaf.are_strength_consistent ( x, str ( inference_1 ), str ( inference_2 ) ) == False ) :
      return False

  return True